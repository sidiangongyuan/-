//版本1，解决非相邻字母对出现最多的问题
#include<fstream>
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
int same(char b[]) {
	char a[100]; 
	strcpy_s(a, b);//之所以不直接用b，怕排序打乱顺序，，他们指向的是同一个地址，会对原始字符串修改
	int i, j, k, same = 0, key = 0;
	char temp;  
	int len = strlen(a);  //字符串长度,无'\0'
	for (i = 0; i < len; i++) {
		k = i;//选择排序
		for (j = i + 1; j < len; j++) {
			if (a[k] > a[j])  k = j;
		}
		if (k != i) {
			temp = a[k];
			a[k] = a[i];
			a[i] = temp;
		}
	}
	//利用双重循环解决重复字母出现次数
	for (i = 0; i < len; i = j)
	{
		for (j = i; j < len; j++) {
			if (a[j] == a[j + 1])
			{
				key++;  //标志，  有相同就 不是0；
				continue;  //前后一致 就 持续 
			}
			j++; break;  //直到某次，在边界， a[j]！=a[j+1]，那么将j指到j+1，也就是不同的字母的开始，i直接跳到j的地方
		}
		if (key != 0) same++;  //利用标志判断出  当前字母是否有相同对，，有的话same++
		key = 0;  //清零，为下一个字母做准备
	}
	return same;    //字母对个数
}
int main() {
	char str[100] = { 0 }; //初始化
	int max = 0, t, len;
	char* temp = new char[10]; 
	ifstream infile("words.txt");  //读取文本文件
	if (infile.fail())
	{
		cout << "open file error" << endl;  //失败
		return -1;
	}
	while (infile.getline(str, sizeof(str), '\n'))  //获取一行
	{
		t = same(str);//返回 相同字母对个数
		len = strlen(str);  //该行 字符串长度，不包括'\0'
		if (t > max)
		{
			max = t;  //更新 最大字母对
			strcpy_s(temp, len + 1, str);//每次遇到 相同字母对 最多的字符串，就 把temp换成当前 字符串
		}   //strcpy_s函数 会自动 对齐temp 和 str（长度，内容全部一致）
	}
	fstream outfile("file.txt", ios::out | ios::app);
	outfile << temp;
	cout << temp;  //最多字母 对的字符串
	infile.close();
	return 0;
}
//版本2  解决相邻的 字母对
#include<iostream>
using namespace std;
typedef int Rank; //秩
 #define DEFAULT_CAPACITY  3 //默认的初始容量（实际应用中可设置为更大）
 template <typename T> class Vector { //向量模板类
 protected:
    Rank _size; int _capacity;  T* _elem; //规模、容量、数据区
	    void copyFrom(T const* A, Rank lo, Rank hi); //复制数组区间A[lo, hi)
public:
	 // 构造函数
	    Vector(int c = DEFAULT_CAPACITY, int s = 0, T v = 0) //容量为c、规模为s、所有元素初始为v
	    { _elem = new T[_capacity = c]; for (_size = 0; _size < s; _elem[_size++] = v); } //s<=c
	    Vector(T const* A, Rank n) { copyFrom(A, 0, n); } //数组整体复制
	    Vector(T const* A, Rank lo, Rank hi) { copyFrom(A, lo, hi); } //区间
	    Vector(Vector<T> const& V) { copyFrom(V._elem, 0, V._size); } //向量整体复制
	    Vector(Vector<T> const& V, Rank lo, Rank hi) { copyFrom(V._elem, lo, hi); } //区间
	 // 析构函数
	    ~Vector() { delete[] _elem; } //释放内部空间
	 // 只读访问接口 
	    Rank size() const { return _size; } //规模
	    bool empty() const { return !_size; } //判空
	    Rank find(T const& e) const { return find(e, 0, _size); } //无序向量整体查找
	    Rank search(T const& e) const //有序向量整体查找
	   { return (0 >= _size) ? -1 : search(e, 0, _size); }
	 // 可写访问接口
		Rank bubble(Rank lo, Rank hi); //扫描交换
		void bubbleSort(Rank lo, Rank hi); //起泡排序算法
		Rank binSearch(T* s, T const& e, Rank lo, Rank hi);
	    Rank insert(T const& e) { return insert(_size, e); } //默认作为末元素插入
	    void sort() { sort(0, _size); } //整体排序
		const T& Entry(int index)const;
		void mergeSort(Rank lo, Rank hi);
		void merge(Rank lo, Rank mi,Rank hi);
}; //Vector
 template<typename T>
 Rank Vector<T>::binSearch(T* s, T const& e, Rank lo, Rank hi) {
	 while (lo < hi) {
		 Rank mi = (lo + hi) >> 1;
		 if (e < s[mi]) hi = mi;
		 else if (s[mi] < e) lo = mi + 1;
		 else return mi;
	 }
	 return -1;
	}
 template < typename T> //元素类型
	  void Vector<T>::copyFrom(T const* A, Rank lo, Rank hi) { //以数组区间A[lo, hi)为蓝本复制向量
	     _elem = new T[_capacity = 2 * (hi - lo)]; _size = 0; //分配空间，规模清零
	     while (lo < hi) //A[lo, hi)内的元素逐一
	     _elem[_size++] = A[lo++]; //复制至_elem[0, hi - lo) 
 }
 template <typename T> void Vector<T>::bubbleSort(Rank lo, Rank hi) { //向量区间[lo, hi)排序
	 while (lo<(hi=bubble(lo,hi)));
 }//判断是否排序结束
 template<typename T> Rank Vector<T>::bubble(Rank lo, Rank hi) {
	 Rank sorted=lo;
	 T temp;
	 while (++lo < hi) {
		 if (_elem[lo - 1] > _elem[lo])
		 {
			 sorted = lo;
			 temp = _elem[lo];
			 _elem[lo] = _elem[lo - 1];
			 _elem[lo - 1] = temp;
		 }
	 }
	 return sorted;
 }//冒泡排序的操作
 template<typename T>const T& Vector<T>::Entry(int index)const {
	 return _elem[index];
 }//返回下标
 /*
#include<fstream>
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
int same(char b[]) {
	char a[100]; 
	int i, j, k, same = 0, key = 0;
	int len = strlen(b);
	/*
	strcpy_s(a, b);//之所以不直接用b，怕排序打乱顺序，，他们指向的是同一个地址，会对原始字符串修改
	char temp;  
	int len = strlen(a);  //字符串长度,无'\0'
	for (i = 0; i < len; i++) {
		k = i;//选择排序
		for (j = i + 1; j < len; j++) {
			if (a[k] > a[j])  k = j;
		}
		if (k != i) {
			temp = a[k];
			a[k] = a[i];
			a[i] = temp;
		}
	}*/
	//利用双重循环解决重复字母出现次数
	for (i = 0; i < len; i = j)
	{
		for (j = i; j < len; j++) {
			if (b[j] == b[j + 1])
			{
				key=1;  //标志，  有相同就 不是0；
				continue;  //前后一致 就 持续 
			}
			j++; break;  //直到某次，在边界， a[j]！=a[j+1]，那么将j指到j+1，也就是不同的字母的开始，i直接跳到j的地方
		}
		if (key != 0) same++;  //利用标志判断出  当前字母是否有相同对，，有的话same++
		key = 0;  //清零，为下一个字母做准备
	}
	return same;    //字母对个数

}
int main() {
	char str[100] = { 0 }; //初始化
	int max = 0, t, len;
	char* temp = new char[10]; 
	ifstream infile("words.txt");  //读取文本文件
	if (infile.fail())
	{
		cout << "open file error" << endl;  //失败
		return -1;
	}
	while (infile.getline(str, sizeof(str), '\n'))  //获取一行
	{
		t = same(str);//返回 相同字母对个数
		len = strlen(str);  //该行 字符串长度，不包括'\0'
		if (t > max)
		{
			max = t;  //更新 最大字母对
			strcpy_s(temp, len + 1, str);//每次遇到 相同字母对 最多的字符串，就 把temp换成当前 字符串
		}   //strcpy_s函数 会自动 对齐temp 和 str（长度，内容全部一致）
	}
	fstream outfile("file.txt", ios::out | ios::app);
	outfile << temp;
	cout << temp;  //最多字母 对的字符串
	infile.close();
	return 0;
}

